/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Actor, HttpAgent, type HttpAgentOptions, type ActorConfig, type Agent, type ActorSubclass } from "@icp-sdk/core/agent";
import type { Principal } from "@icp-sdk/core/principal";
import { idlFactory, type _SERVICE } from "./declarations/backend.did";
export interface Some<T> {
    __kind__: "Some";
    value: T;
}
export interface None {
    __kind__: "None";
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
    return {
        __kind__: "Some",
        value: value
    };
}
function none(): None {
    return {
        __kind__: "None"
    };
}
function isNone<T>(option: Option<T>): option is None {
    return option.__kind__ === "None";
}
function isSome<T>(option: Option<T>): option is Some<T> {
    return option.__kind__ === "Some";
}
function unwrap<T>(option: Option<T>): T {
    if (isNone(option)) {
        throw new Error("unwrap: none");
    }
    return option.value;
}
function candid_some<T>(value: T): [T] {
    return [
        value
    ];
}
function candid_none<T>(): [] {
    return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
    return arg == null ? undefined : arg;
}
export class ExternalBlob {
    _blob?: Uint8Array<ArrayBuffer> | null;
    directURL: string;
    onProgress?: (percentage: number) => void = undefined;
    private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null){
        if (blob) {
            this._blob = blob;
        }
        this.directURL = directURL;
    }
    static fromURL(url: string): ExternalBlob {
        return new ExternalBlob(url, null);
    }
    static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
        const url = URL.createObjectURL(new Blob([
            new Uint8Array(blob)
        ], {
            type: 'application/octet-stream'
        }));
        return new ExternalBlob(url, blob);
    }
    public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
        if (this._blob) {
            return this._blob;
        }
        const response = await fetch(this.directURL);
        const blob = await response.blob();
        this._blob = new Uint8Array(await blob.arrayBuffer());
        return this._blob;
    }
    public getDirectURL(): string {
        return this.directURL;
    }
    public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
        this.onProgress = onProgress;
        return this;
    }
}
export interface WebhookAlert {
    status: WebhookStatus;
    received_at: Time;
    action?: string;
    ticker?: string;
    strategy?: string;
    alert_name?: string;
    raw_payload: string;
    alert_id: string;
}
export type Time = bigint;
export interface ReceiveWebhookResponse {
    ok: boolean;
    error?: string;
    trace_id?: TraceId;
}
export interface Fill {
    fill_time: Time;
    trace_id: TraceId;
    price: number;
}
export interface TraceInput {
    action: string;
    ticker: string;
    take_profit: number;
    strategy: string;
    params_snapshot_json: string;
    entry: number;
    stop_loss: number;
}
export type TraceId = string;
export type WebhookStatus = {
    __kind__: "error";
    error: string;
} | {
    __kind__: "processed";
    processed: null;
} | {
    __kind__: "received";
    received: null;
};
export interface Settings {
    pipeline_test_mode: boolean;
    ghost_exit_warn_ratio: number;
    ghost_api_key: string;
    tradovate_live_url: string;
    ghost_markup_pct: number;
    ghost_exit_warn_time_sec: bigint;
    risk_method: RiskMethod;
    max_trade_quantity: bigint;
    ghost_executed_from_devices: Array<string>;
    ghost_webhook_url: string;
    tradovate_api_key: string;
    tradovate_demo_url: string;
    ghost_trade_max_qty_scale: bigint;
    ghost_spread_threshold: number;
}
export interface TraceQueryFilters {
    ticker?: string;
    strategy?: string;
    ghost_status?: GhostStatus;
    end_time?: Time;
    start_time?: Time;
    tradovate_status?: TradeStatus;
}
export interface TraceEvent {
    id: bigint;
    source: EventSource;
    trace_id: TraceId;
    event_time: Time;
    event_type: EventType;
}
export interface Trace {
    pnl?: number;
    updated_at: Time;
    action: string;
    ticker: string;
    take_profit: number;
    alert_received_at: Time;
    duration_seconds?: bigint;
    strategy: string;
    ghost_status: GhostStatus;
    created_at: Time;
    entry: number;
    avg_entry?: number;
    stop_loss: number;
    trace_id: TraceId;
    avg_exit?: number;
    tradovate_status: TradeStatus;
}
export enum EventSource {
    tradovate = "tradovate",
    ghost = "ghost",
    tradingview = "tradingview"
}
export enum EventType {
    tradingviewEvent = "tradingviewEvent",
    ghostForwardAttempt = "ghostForwardAttempt",
    validationError = "validationError",
    ghostForwardSuccess = "ghostForwardSuccess",
    ghostForwardFailure = "ghostForwardFailure",
    alertReceived = "alertReceived",
    ghostCallback = "ghostCallback"
}
export enum GhostStatus {
    rejected = "rejected",
    accepted = "accepted",
    unknown_ = "unknown",
    received = "received"
}
export enum RiskMethod {
    percentBalance = "percentBalance",
    fixedQuantity = "fixedQuantity"
}
export enum TradeStatus {
    canceled = "canceled",
    submitted = "submitted",
    filled = "filled",
    working = "working",
    rejected = "rejected",
    unknown_ = "unknown"
}
export interface backendInterface {
    filterTraces(filters: TraceQueryFilters): Promise<Array<Trace>>;
    getSettings(): Promise<Settings>;
    getTrace(trace_id: TraceId): Promise<Trace | null>;
    getTraceEvents(trace_id: TraceId): Promise<Array<TraceEvent>>;
    getTraceFills(trace_id: TraceId): Promise<Array<Fill>>;
    getWebhookAlert(alert_id: string): Promise<WebhookAlert | null>;
    getWebhookAlerts(): Promise<Array<WebhookAlert>>;
    listTraces(): Promise<Array<Trace>>;
    receiveGhostCallback(_payload_json: string): Promise<void>;
    receiveWebhook(traceInput: TraceInput | null, traceId: TraceId): Promise<ReceiveWebhookResponse>;
    refreshTrace(_trace_id: TraceId): Promise<void>;
    saveSettings(_settings: Settings): Promise<void>;
    updateGhostStatus(_trace_id: TraceId, _status: GhostStatus, _response_json: string, _error: string | null): Promise<void>;
}
import type { EventSource as _EventSource, EventType as _EventType, GhostStatus as _GhostStatus, ReceiveWebhookResponse as _ReceiveWebhookResponse, RiskMethod as _RiskMethod, Settings as _Settings, Time as _Time, Trace as _Trace, TraceEvent as _TraceEvent, TraceId as _TraceId, TraceInput as _TraceInput, TraceQueryFilters as _TraceQueryFilters, TradeStatus as _TradeStatus, WebhookAlert as _WebhookAlert, WebhookStatus as _WebhookStatus } from "./declarations/backend.did.d.ts";
export class Backend implements backendInterface {
    constructor(private actor: ActorSubclass<_SERVICE>, private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, private processError?: (error: unknown) => never){}
    async filterTraces(arg0: TraceQueryFilters): Promise<Array<Trace>> {
        if (this.processError) {
            try {
                const result = await this.actor.filterTraces(to_candid_TraceQueryFilters_n1(this._uploadFile, this._downloadFile, arg0));
                return from_candid_vec_n7(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.filterTraces(to_candid_TraceQueryFilters_n1(this._uploadFile, this._downloadFile, arg0));
            return from_candid_vec_n7(this._uploadFile, this._downloadFile, result);
        }
    }
    async getSettings(): Promise<Settings> {
        if (this.processError) {
            try {
                const result = await this.actor.getSettings();
                return from_candid_Settings_n16(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getSettings();
            return from_candid_Settings_n16(this._uploadFile, this._downloadFile, result);
        }
    }
    async getTrace(arg0: TraceId): Promise<Trace | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getTrace(arg0);
                return from_candid_opt_n20(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTrace(arg0);
            return from_candid_opt_n20(this._uploadFile, this._downloadFile, result);
        }
    }
    async getTraceEvents(arg0: TraceId): Promise<Array<TraceEvent>> {
        if (this.processError) {
            try {
                const result = await this.actor.getTraceEvents(arg0);
                return from_candid_vec_n21(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTraceEvents(arg0);
            return from_candid_vec_n21(this._uploadFile, this._downloadFile, result);
        }
    }
    async getTraceFills(arg0: TraceId): Promise<Array<Fill>> {
        if (this.processError) {
            try {
                const result = await this.actor.getTraceFills(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTraceFills(arg0);
            return result;
        }
    }
    async getWebhookAlert(arg0: string): Promise<WebhookAlert | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getWebhookAlert(arg0);
                return from_candid_opt_n28(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getWebhookAlert(arg0);
            return from_candid_opt_n28(this._uploadFile, this._downloadFile, result);
        }
    }
    async getWebhookAlerts(): Promise<Array<WebhookAlert>> {
        if (this.processError) {
            try {
                const result = await this.actor.getWebhookAlerts();
                return from_candid_vec_n34(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getWebhookAlerts();
            return from_candid_vec_n34(this._uploadFile, this._downloadFile, result);
        }
    }
    async listTraces(): Promise<Array<Trace>> {
        if (this.processError) {
            try {
                const result = await this.actor.listTraces();
                return from_candid_vec_n7(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listTraces();
            return from_candid_vec_n7(this._uploadFile, this._downloadFile, result);
        }
    }
    async receiveGhostCallback(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.receiveGhostCallback(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.receiveGhostCallback(arg0);
            return result;
        }
    }
    async receiveWebhook(arg0: TraceInput | null, arg1: TraceId): Promise<ReceiveWebhookResponse> {
        if (this.processError) {
            try {
                const result = await this.actor.receiveWebhook(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0), arg1);
                return from_candid_ReceiveWebhookResponse_n36(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.receiveWebhook(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0), arg1);
            return from_candid_ReceiveWebhookResponse_n36(this._uploadFile, this._downloadFile, result);
        }
    }
    async refreshTrace(arg0: TraceId): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.refreshTrace(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.refreshTrace(arg0);
            return result;
        }
    }
    async saveSettings(arg0: Settings): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveSettings(to_candid_Settings_n39(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveSettings(to_candid_Settings_n39(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async updateGhostStatus(arg0: TraceId, arg1: GhostStatus, arg2: string, arg3: string | null): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateGhostStatus(arg0, to_candid_GhostStatus_n3(this._uploadFile, this._downloadFile, arg1), arg2, to_candid_opt_n43(this._uploadFile, this._downloadFile, arg3));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateGhostStatus(arg0, to_candid_GhostStatus_n3(this._uploadFile, this._downloadFile, arg1), arg2, to_candid_opt_n43(this._uploadFile, this._downloadFile, arg3));
            return result;
        }
    }
}
function from_candid_EventSource_n24(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _EventSource): EventSource {
    return from_candid_variant_n25(_uploadFile, _downloadFile, value);
}
function from_candid_EventType_n26(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _EventType): EventType {
    return from_candid_variant_n27(_uploadFile, _downloadFile, value);
}
function from_candid_GhostStatus_n12(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _GhostStatus): GhostStatus {
    return from_candid_variant_n13(_uploadFile, _downloadFile, value);
}
function from_candid_ReceiveWebhookResponse_n36(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _ReceiveWebhookResponse): ReceiveWebhookResponse {
    return from_candid_record_n37(_uploadFile, _downloadFile, value);
}
function from_candid_RiskMethod_n18(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _RiskMethod): RiskMethod {
    return from_candid_variant_n19(_uploadFile, _downloadFile, value);
}
function from_candid_Settings_n16(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Settings): Settings {
    return from_candid_record_n17(_uploadFile, _downloadFile, value);
}
function from_candid_TraceEvent_n22(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _TraceEvent): TraceEvent {
    return from_candid_record_n23(_uploadFile, _downloadFile, value);
}
function from_candid_Trace_n8(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Trace): Trace {
    return from_candid_record_n9(_uploadFile, _downloadFile, value);
}
function from_candid_TradeStatus_n14(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _TradeStatus): TradeStatus {
    return from_candid_variant_n15(_uploadFile, _downloadFile, value);
}
function from_candid_WebhookAlert_n29(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _WebhookAlert): WebhookAlert {
    return from_candid_record_n30(_uploadFile, _downloadFile, value);
}
function from_candid_WebhookStatus_n31(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _WebhookStatus): WebhookStatus {
    return from_candid_variant_n32(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n10(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [number]): number | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n11(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [bigint]): bigint | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n20(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_Trace]): Trace | null {
    return value.length === 0 ? null : from_candid_Trace_n8(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n28(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_WebhookAlert]): WebhookAlert | null {
    return value.length === 0 ? null : from_candid_WebhookAlert_n29(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n33(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [string]): string | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n38(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_TraceId]): TraceId | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_record_n17(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    pipeline_test_mode: boolean;
    ghost_exit_warn_ratio: number;
    ghost_api_key: string;
    tradovate_live_url: string;
    ghost_markup_pct: number;
    ghost_exit_warn_time_sec: bigint;
    risk_method: _RiskMethod;
    max_trade_quantity: bigint;
    ghost_executed_from_devices: Array<string>;
    ghost_webhook_url: string;
    tradovate_api_key: string;
    tradovate_demo_url: string;
    ghost_trade_max_qty_scale: bigint;
    ghost_spread_threshold: number;
}): {
    pipeline_test_mode: boolean;
    ghost_exit_warn_ratio: number;
    ghost_api_key: string;
    tradovate_live_url: string;
    ghost_markup_pct: number;
    ghost_exit_warn_time_sec: bigint;
    risk_method: RiskMethod;
    max_trade_quantity: bigint;
    ghost_executed_from_devices: Array<string>;
    ghost_webhook_url: string;
    tradovate_api_key: string;
    tradovate_demo_url: string;
    ghost_trade_max_qty_scale: bigint;
    ghost_spread_threshold: number;
} {
    return {
        pipeline_test_mode: value.pipeline_test_mode,
        ghost_exit_warn_ratio: value.ghost_exit_warn_ratio,
        ghost_api_key: value.ghost_api_key,
        tradovate_live_url: value.tradovate_live_url,
        ghost_markup_pct: value.ghost_markup_pct,
        ghost_exit_warn_time_sec: value.ghost_exit_warn_time_sec,
        risk_method: from_candid_RiskMethod_n18(_uploadFile, _downloadFile, value.risk_method),
        max_trade_quantity: value.max_trade_quantity,
        ghost_executed_from_devices: value.ghost_executed_from_devices,
        ghost_webhook_url: value.ghost_webhook_url,
        tradovate_api_key: value.tradovate_api_key,
        tradovate_demo_url: value.tradovate_demo_url,
        ghost_trade_max_qty_scale: value.ghost_trade_max_qty_scale,
        ghost_spread_threshold: value.ghost_spread_threshold
    };
}
function from_candid_record_n23(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: bigint;
    source: _EventSource;
    trace_id: _TraceId;
    event_time: _Time;
    event_type: _EventType;
}): {
    id: bigint;
    source: EventSource;
    trace_id: TraceId;
    event_time: Time;
    event_type: EventType;
} {
    return {
        id: value.id,
        source: from_candid_EventSource_n24(_uploadFile, _downloadFile, value.source),
        trace_id: value.trace_id,
        event_time: value.event_time,
        event_type: from_candid_EventType_n26(_uploadFile, _downloadFile, value.event_type)
    };
}
function from_candid_record_n30(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    status: _WebhookStatus;
    received_at: _Time;
    action: [] | [string];
    ticker: [] | [string];
    strategy: [] | [string];
    alert_name: [] | [string];
    raw_payload: string;
    alert_id: string;
}): {
    status: WebhookStatus;
    received_at: Time;
    action?: string;
    ticker?: string;
    strategy?: string;
    alert_name?: string;
    raw_payload: string;
    alert_id: string;
} {
    return {
        status: from_candid_WebhookStatus_n31(_uploadFile, _downloadFile, value.status),
        received_at: value.received_at,
        action: record_opt_to_undefined(from_candid_opt_n33(_uploadFile, _downloadFile, value.action)),
        ticker: record_opt_to_undefined(from_candid_opt_n33(_uploadFile, _downloadFile, value.ticker)),
        strategy: record_opt_to_undefined(from_candid_opt_n33(_uploadFile, _downloadFile, value.strategy)),
        alert_name: record_opt_to_undefined(from_candid_opt_n33(_uploadFile, _downloadFile, value.alert_name)),
        raw_payload: value.raw_payload,
        alert_id: value.alert_id
    };
}
function from_candid_record_n37(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    ok: boolean;
    error: [] | [string];
    trace_id: [] | [_TraceId];
}): {
    ok: boolean;
    error?: string;
    trace_id?: TraceId;
} {
    return {
        ok: value.ok,
        error: record_opt_to_undefined(from_candid_opt_n33(_uploadFile, _downloadFile, value.error)),
        trace_id: record_opt_to_undefined(from_candid_opt_n38(_uploadFile, _downloadFile, value.trace_id))
    };
}
function from_candid_record_n9(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    pnl: [] | [number];
    updated_at: _Time;
    action: string;
    ticker: string;
    take_profit: number;
    alert_received_at: _Time;
    duration_seconds: [] | [bigint];
    strategy: string;
    ghost_status: _GhostStatus;
    created_at: _Time;
    entry: number;
    avg_entry: [] | [number];
    stop_loss: number;
    trace_id: _TraceId;
    avg_exit: [] | [number];
    tradovate_status: _TradeStatus;
}): {
    pnl?: number;
    updated_at: Time;
    action: string;
    ticker: string;
    take_profit: number;
    alert_received_at: Time;
    duration_seconds?: bigint;
    strategy: string;
    ghost_status: GhostStatus;
    created_at: Time;
    entry: number;
    avg_entry?: number;
    stop_loss: number;
    trace_id: TraceId;
    avg_exit?: number;
    tradovate_status: TradeStatus;
} {
    return {
        pnl: record_opt_to_undefined(from_candid_opt_n10(_uploadFile, _downloadFile, value.pnl)),
        updated_at: value.updated_at,
        action: value.action,
        ticker: value.ticker,
        take_profit: value.take_profit,
        alert_received_at: value.alert_received_at,
        duration_seconds: record_opt_to_undefined(from_candid_opt_n11(_uploadFile, _downloadFile, value.duration_seconds)),
        strategy: value.strategy,
        ghost_status: from_candid_GhostStatus_n12(_uploadFile, _downloadFile, value.ghost_status),
        created_at: value.created_at,
        entry: value.entry,
        avg_entry: record_opt_to_undefined(from_candid_opt_n10(_uploadFile, _downloadFile, value.avg_entry)),
        stop_loss: value.stop_loss,
        trace_id: value.trace_id,
        avg_exit: record_opt_to_undefined(from_candid_opt_n10(_uploadFile, _downloadFile, value.avg_exit)),
        tradovate_status: from_candid_TradeStatus_n14(_uploadFile, _downloadFile, value.tradovate_status)
    };
}
function from_candid_variant_n13(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    rejected: null;
} | {
    accepted: null;
} | {
    unknown: null;
} | {
    received: null;
}): GhostStatus {
    return "rejected" in value ? GhostStatus.rejected : "accepted" in value ? GhostStatus.accepted : "unknown" in value ? GhostStatus.unknown : "received" in value ? GhostStatus.received : value;
}
function from_candid_variant_n15(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    canceled: null;
} | {
    submitted: null;
} | {
    filled: null;
} | {
    working: null;
} | {
    rejected: null;
} | {
    unknown: null;
}): TradeStatus {
    return "canceled" in value ? TradeStatus.canceled : "submitted" in value ? TradeStatus.submitted : "filled" in value ? TradeStatus.filled : "working" in value ? TradeStatus.working : "rejected" in value ? TradeStatus.rejected : "unknown" in value ? TradeStatus.unknown : value;
}
function from_candid_variant_n19(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    percentBalance: null;
} | {
    fixedQuantity: null;
}): RiskMethod {
    return "percentBalance" in value ? RiskMethod.percentBalance : "fixedQuantity" in value ? RiskMethod.fixedQuantity : value;
}
function from_candid_variant_n25(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    tradovate: null;
} | {
    ghost: null;
} | {
    tradingview: null;
}): EventSource {
    return "tradovate" in value ? EventSource.tradovate : "ghost" in value ? EventSource.ghost : "tradingview" in value ? EventSource.tradingview : value;
}
function from_candid_variant_n27(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    tradingviewEvent: null;
} | {
    ghostForwardAttempt: null;
} | {
    validationError: null;
} | {
    ghostForwardSuccess: null;
} | {
    ghostForwardFailure: null;
} | {
    alertReceived: null;
} | {
    ghostCallback: null;
}): EventType {
    return "tradingviewEvent" in value ? EventType.tradingviewEvent : "ghostForwardAttempt" in value ? EventType.ghostForwardAttempt : "validationError" in value ? EventType.validationError : "ghostForwardSuccess" in value ? EventType.ghostForwardSuccess : "ghostForwardFailure" in value ? EventType.ghostForwardFailure : "alertReceived" in value ? EventType.alertReceived : "ghostCallback" in value ? EventType.ghostCallback : value;
}
function from_candid_variant_n32(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    error: string;
} | {
    processed: null;
} | {
    received: null;
}): {
    __kind__: "error";
    error: string;
} | {
    __kind__: "processed";
    processed: null;
} | {
    __kind__: "received";
    received: null;
} {
    return "error" in value ? {
        __kind__: "error",
        error: value.error
    } : "processed" in value ? {
        __kind__: "processed",
        processed: value.processed
    } : "received" in value ? {
        __kind__: "received",
        received: value.received
    } : value;
}
function from_candid_vec_n21(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_TraceEvent>): Array<TraceEvent> {
    return value.map((x)=>from_candid_TraceEvent_n22(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n34(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_WebhookAlert>): Array<WebhookAlert> {
    return value.map((x)=>from_candid_WebhookAlert_n29(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n7(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_Trace>): Array<Trace> {
    return value.map((x)=>from_candid_Trace_n8(_uploadFile, _downloadFile, x));
}
function to_candid_GhostStatus_n3(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: GhostStatus): _GhostStatus {
    return to_candid_variant_n4(_uploadFile, _downloadFile, value);
}
function to_candid_RiskMethod_n41(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: RiskMethod): _RiskMethod {
    return to_candid_variant_n42(_uploadFile, _downloadFile, value);
}
function to_candid_Settings_n39(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Settings): _Settings {
    return to_candid_record_n40(_uploadFile, _downloadFile, value);
}
function to_candid_TraceQueryFilters_n1(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: TraceQueryFilters): _TraceQueryFilters {
    return to_candid_record_n2(_uploadFile, _downloadFile, value);
}
function to_candid_TradeStatus_n5(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: TradeStatus): _TradeStatus {
    return to_candid_variant_n6(_uploadFile, _downloadFile, value);
}
function to_candid_opt_n35(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: TraceInput | null): [] | [_TraceInput] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_opt_n43(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: string | null): [] | [string] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_record_n2(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    ticker?: string;
    strategy?: string;
    ghost_status?: GhostStatus;
    end_time?: Time;
    start_time?: Time;
    tradovate_status?: TradeStatus;
}): {
    ticker: [] | [string];
    strategy: [] | [string];
    ghost_status: [] | [_GhostStatus];
    end_time: [] | [_Time];
    start_time: [] | [_Time];
    tradovate_status: [] | [_TradeStatus];
} {
    return {
        ticker: value.ticker ? candid_some(value.ticker) : candid_none(),
        strategy: value.strategy ? candid_some(value.strategy) : candid_none(),
        ghost_status: value.ghost_status ? candid_some(to_candid_GhostStatus_n3(_uploadFile, _downloadFile, value.ghost_status)) : candid_none(),
        end_time: value.end_time ? candid_some(value.end_time) : candid_none(),
        start_time: value.start_time ? candid_some(value.start_time) : candid_none(),
        tradovate_status: value.tradovate_status ? candid_some(to_candid_TradeStatus_n5(_uploadFile, _downloadFile, value.tradovate_status)) : candid_none()
    };
}
function to_candid_record_n40(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    pipeline_test_mode: boolean;
    ghost_exit_warn_ratio: number;
    ghost_api_key: string;
    tradovate_live_url: string;
    ghost_markup_pct: number;
    ghost_exit_warn_time_sec: bigint;
    risk_method: RiskMethod;
    max_trade_quantity: bigint;
    ghost_executed_from_devices: Array<string>;
    ghost_webhook_url: string;
    tradovate_api_key: string;
    tradovate_demo_url: string;
    ghost_trade_max_qty_scale: bigint;
    ghost_spread_threshold: number;
}): {
    pipeline_test_mode: boolean;
    ghost_exit_warn_ratio: number;
    ghost_api_key: string;
    tradovate_live_url: string;
    ghost_markup_pct: number;
    ghost_exit_warn_time_sec: bigint;
    risk_method: _RiskMethod;
    max_trade_quantity: bigint;
    ghost_executed_from_devices: Array<string>;
    ghost_webhook_url: string;
    tradovate_api_key: string;
    tradovate_demo_url: string;
    ghost_trade_max_qty_scale: bigint;
    ghost_spread_threshold: number;
} {
    return {
        pipeline_test_mode: value.pipeline_test_mode,
        ghost_exit_warn_ratio: value.ghost_exit_warn_ratio,
        ghost_api_key: value.ghost_api_key,
        tradovate_live_url: value.tradovate_live_url,
        ghost_markup_pct: value.ghost_markup_pct,
        ghost_exit_warn_time_sec: value.ghost_exit_warn_time_sec,
        risk_method: to_candid_RiskMethod_n41(_uploadFile, _downloadFile, value.risk_method),
        max_trade_quantity: value.max_trade_quantity,
        ghost_executed_from_devices: value.ghost_executed_from_devices,
        ghost_webhook_url: value.ghost_webhook_url,
        tradovate_api_key: value.tradovate_api_key,
        tradovate_demo_url: value.tradovate_demo_url,
        ghost_trade_max_qty_scale: value.ghost_trade_max_qty_scale,
        ghost_spread_threshold: value.ghost_spread_threshold
    };
}
function to_candid_variant_n4(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: GhostStatus): {
    rejected: null;
} | {
    accepted: null;
} | {
    unknown: null;
} | {
    received: null;
} {
    return value == GhostStatus.rejected ? {
        rejected: null
    } : value == GhostStatus.accepted ? {
        accepted: null
    } : value == GhostStatus.unknown ? {
        unknown_: null
    } : value == GhostStatus.received ? {
        received: null
    } : value;
}
function to_candid_variant_n42(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: RiskMethod): {
    percentBalance: null;
} | {
    fixedQuantity: null;
} {
    return value == RiskMethod.percentBalance ? {
        percentBalance: null
    } : value == RiskMethod.fixedQuantity ? {
        fixedQuantity: null
    } : value;
}
function to_candid_variant_n6(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: TradeStatus): {
    canceled: null;
} | {
    submitted: null;
} | {
    filled: null;
} | {
    working: null;
} | {
    rejected: null;
} | {
    unknown: null;
} {
    return value == TradeStatus.canceled ? {
        canceled: null
    } : value == TradeStatus.submitted ? {
        submitted: null
    } : value == TradeStatus.filled ? {
        filled: null
    } : value == TradeStatus.working ? {
        working: null
    } : value == TradeStatus.rejected ? {
        rejected: null
    } : value == TradeStatus.unknown ? {
        unknown_: null
    } : value;
}
export interface CreateActorOptions {
    agent?: Agent;
    agentOptions?: HttpAgentOptions;
    actorOptions?: ActorConfig;
    processError?: (error: unknown) => never;
}
export function createActor(canisterId: string, _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, options: CreateActorOptions = {}): Backend {
    const agent = options.agent || HttpAgent.createSync({
        ...options.agentOptions
    });
    if (options.agent && options.agentOptions) {
        console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.");
    }
    const actor = Actor.createActor<_SERVICE>(idlFactory, {
        agent,
        canisterId: canisterId,
        ...options.actorOptions
    });
    return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
